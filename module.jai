// in the future I don't want to depend on all of geom, because all I need is the itp type doing it for now.
#import "geometry";

#load "axis_aligned_bounding_box.jai";

#import "Math";
#import "Basic";

Collision_Geometry :: struct {
    indexed_triangle_positions : Indexed_Triangle_Positions;
    aabb : AABB;
}

Collision_Result :: struct {
    occurred := false;
    face_normal_generating_least_overlap : Vector3;
    overlap_along_normal : float;
    normal_is_pointing_towards_collision: bool;
}

compute_normal_of_triangle :: (a: Vector3, b: Vector3, c: Vector3) -> Vector3  {
    return normalized_cross(b - a, c - a);
}


// uses the separating axis theorem, worst case runtime is n * m where n and m are the number of faces on each shape respectively.
// this makes it cheap on simple objects, but not for complex ones.

detect_convex_collision :: (obj_1: Indexed_Triangle_Positions, obj_1_origin: Vector3, obj_2: Indexed_Triangle_Positions, obj_2_origin: Vector3) -> Collision_Result {

    collision_result : Collision_Result;

    min_overlap_so_far : float = FLOAT32_MAX;
    face_normal_generating_least_overlap : Vector3;

    // note that it's possible for this to be false, because if you have an axis aligned cube
    // then it's possible that the first face creates the min, and it could have been the paralell face that's pointing away
    normal_is_pointing_towards_collision := false;

    // note this is pretty wasteful, but I'm just focusing on making the algorithm work first.
    // we could compute as we go so that we don't waste.
    
    face_normals_on_all_objects : [..] Vector3;
    defer array_free(face_normals_on_all_objects);

    i := 0;
    while i + 2 < obj_1.indices.count {

        normal := compute_normal_of_triangle(
            obj_1.positions[obj_1.indices[i]], 
            obj_1.positions[obj_1.indices[i + 1]], 
            obj_1.positions[obj_1.indices[i + 2]], 
        );


        array_add(*face_normals_on_all_objects, normal);
        i += 3;
    }

    i = 0;
    while i + 2 < obj_2.indices.count {

        normal := compute_normal_of_triangle(
            obj_2.positions[obj_2.indices[i]], 
            obj_2.positions[obj_2.indices[i + 1]], 
            obj_2.positions[obj_2.indices[i + 2]], 
        );


        array_add(*face_normals_on_all_objects, normal);
        i += 3;
    }

    for face_normal : face_normals_on_all_objects {

        obj_1_min_projection_on_line_defined_by_face_normal := FLOAT32_MAX;
        obj_1_max_projection_on_line_defined_by_face_normal := -FLOAT32_MAX;

        for v : obj_1.positions {
            // recall that the dot product is ||a|| * ||b|| cos(theta)
            // where theta is the angle between the vectors a and b, if we suppose that b is a normal vector then
            // the equation becomes
            // ||a|| cos(theta), Since we know that cos(theta) = adj/hyp, and if we drop a perpendicular from a onto
            // the ray generated by b, then we can deduce that adj of that triangle equals hyp * cos(theta) and here
            // we know that ||a|| = hyp, therefore dot(v, face_normal) is the projection of the vertex v along the
            // normal vector's generated line

            projection_along_line_generated_by_face_normal : float = dot(v + obj_1_origin, face_normal);
            obj_1_min_projection_on_line_defined_by_face_normal = min(obj_1_min_projection_on_line_defined_by_face_normal, projection_along_line_generated_by_face_normal);
            obj_1_max_projection_on_line_defined_by_face_normal = max(obj_1_max_projection_on_line_defined_by_face_normal, projection_along_line_generated_by_face_normal);
        }

        obj_2_min_projection_on_line_defined_by_face_normal := FLOAT32_MAX;
        obj_2_max_projection_on_line_defined_by_face_normal := -FLOAT32_MAX;

        for v : obj_2.positions {
            projection_along_line_generated_by_face_normal : float = dot(v + obj_2_origin, face_normal);
            obj_2_min_projection_on_line_defined_by_face_normal = min(obj_2_min_projection_on_line_defined_by_face_normal, projection_along_line_generated_by_face_normal);
            obj_2_max_projection_on_line_defined_by_face_normal = max(obj_2_max_projection_on_line_defined_by_face_normal, projection_along_line_generated_by_face_normal);
        }

        overlap := min(obj_1_max_projection_on_line_defined_by_face_normal, obj_2_max_projection_on_line_defined_by_face_normal) -
                   max(obj_1_min_projection_on_line_defined_by_face_normal, obj_2_min_projection_on_line_defined_by_face_normal);

        if (overlap < 0) {
            // separating axis found, no collision (by the separating axis theorem)
            return collision_result;
        } else {
            // overlap was found on this line, but that doesn't mean they collide, they only collide if this occurs on all face normal lines.
        }

        if (overlap < min_overlap_so_far) {
            min_overlap_so_far = overlap;
            face_normal_generating_least_overlap = face_normal;

            // this measurement tells us this information because if you have two vectors a, b in space, and suppose
            // against some plane defined by v (unit vector) such that the projection of a onto v is 3 and the
            // projection of b on to v is 4, then you'll find the that projection of a onto -v is -3 and the projection
            // of b onto -v is -4. Note that 3 < 4 and then -3 > -4, thus this is why it works.
            normal_is_pointing_towards_collision = obj_1_max_projection_on_line_defined_by_face_normal > obj_2_max_projection_on_line_defined_by_face_normal;
        }
    }

    // note: if you get to this line in the code we know that the a collision has occurred, because no early return has been hit.
    
    collision_result.occurred = true;
    collision_result.face_normal_generating_least_overlap = face_normal_generating_least_overlap;

    collision_result.overlap_along_normal = min_overlap_so_far;
    collision_result.normal_is_pointing_towards_collision = normal_is_pointing_towards_collision;

    return collision_result;
}

// assumes that all objects are convex!
resolve_collisions_against_body :: (positioned_colliders : [] Collision_Geometry, body_collider: Collision_Geometry, body_position : *Vector3, body_velocity : *Vector3, on_ground: *bool) {

    on_ground.* = false;
    positioned_body_aabb := change_aabb_origin(body_collider.aabb, body_position);

    for collider : positioned_colliders {
        if aabbs_are_disjoint(collider.aabb, positioned_body_aabb) {
            continue;
        } 

        collision_result := detect_convex_collision(body_collider.indexed_triangle_positions, body_position, collider.indexed_triangle_positions, ZERO3);
        
        if (collision_result.occurred) {
            normal_facing_towards_body := ifx collision_result.normal_is_pointing_towards_collision then collision_result.face_normal_generating_least_overlap else -collision_result.face_normal_generating_least_overlap;

            pos_offset_to_escape_collision := normal_facing_towards_body * collision_result.overlap_along_normal;
            body_position.* += pos_offset_to_escape_collision;

            projected_velocity_length_along_normal := dot(body_velocity, normal_facing_towards_body);
            velocity_is_going_opposite_direction_of_push := projected_velocity_length_along_normal < 0.0;

            if (velocity_is_going_opposite_direction_of_push)
                body_velocity.* -= projected_velocity_length_along_normal * normal_facing_towards_body;

            up_alignment := dot(normal_facing_towards_body, Y3);
            cos_45 := 0.707;

            if (up_alignment > cos_45) {
                on_ground.* = true;
            }
        } // otherwise aabbs collided but the inner geometry did not.
    }
}


